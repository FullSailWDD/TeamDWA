'use strict';

// This static list of commands is updated from time to time.
// ./lib/commands.js can be updated with generate_commands.js
var commands = require('./commands');
var utils = require('./utils');
var redis = require('../index');
var RedisClient = redis.RedisClient;
var Multi = redis.Multi;

commands.forEach(function (fullCommand) {
    var command = fullCommand.split(' ')[0];

    // Skip all full commands that have already been added instead of overwriting them over and over again
    if (RedisClient.prototype[command]) {
        return;
    }

    RedisClient.prototype[command] = function (key, arg, callback) {
        if (Array.isArray(key)) {
            return this.send_command(command, key, arg);
        }
        if (Array.isArray(arg)) {
            arg = [key].concat(arg);
            return this.send_command(command, arg, callback);
        }
        // Speed up the common case
        var len = arguments.length;
        if (len === 2) {
            return this.send_command(command, [key, arg]);
        }
        if (len === 3) {
            return this.send_command(command, [key, arg, callback]);
        }
        return this.send_command(command, utils.to_array(arguments));
    };
    RedisClient.prototype[command.toUpperCase()] = RedisClient.prototype[command];

    Multi.prototype[command] = function (key, arg, callback) {
        if (Array.isArray(key)) {
            if (arg) {
                key = key.concat([arg]);
            }
            this.queue.push([command].concat(key));
        } else if (Array.isArray(arg)) {
            if (callback) {
                arg = arg.concat([callback]);
            }
            this.queue.push([command, key].concat(arg));
        } else {
            // Speed up the common case
            var len = arguments.length;
            if (len === 2) {
                this.queue.push([command, key, arg]);
            } else if (len === 3) {
                this.queue.push([command, key, arg, callback]);
            } else {
                this.queue.push([command].concat(utils.to_array(arguments)));
            }
        }
        return this;
    };
    Multi.prototype[command.toUpperCase()] = Multi.prototype[command];
});

// store db in this.select_db to restore it on reconnect
RedisClient.prototype.select = RedisClient.prototype.SELECT = function (db, callback) {
    var self = this;

    this.send_command('select', [db], function (err, res) {
        if (err === null) {
            self.selected_db = db;
        }
        if (typeof callback === 'function') {
            callback(err, res);
        } else if (err) {
            self.emit('error', err);
        }
    });
};

// Stash auth for connect and reconnect. Send immediately if already connected.
RedisClient.prototype.auth = RedisClient.prototype.AUTH = function (pass, callback) {
    if (typeof pass !== 'string') {
        var err = new Error('The password has to be of type "string"');
        err.command = 'AUTH';
        if (callback) {
            callback(err);
        } else {
            this.emit('error', err);
        }
        return;
    }
    this.auth_pass = pass;
    // debug("Saving auth as " + this.auth_pass);
    // Only run the callback once. So do not safe it if already connected
    if (this.connected) {
        this.send_command("auth", [this.auth_pass], callback);
    } else {
        this.auth_callback = callback;
    }
};

RedisClient.prototype.hmset = RedisClient.prototype.HMSET = function (key, args, callback) {
    var field, tmp_args;
    if (Array.isArray(key)) {
        return this.send_command("hmset", key, args);
    }
    if (Array.isArray(args)) {
        return this.send_command("hmset", [key].concat(args), callback);
    }
    if (typeof args === "object") {
        // User does: client.hmset(key, {key1: val1, key2: val2})
        // assuming key is a string, i.e. email address

        // if key is a number, i.e. timestamp, convert to string
        // TODO: This seems random and no other command get's the key converted => either all or none should behave like this
        if (typeof key !== "string") {
            key = key.toString();
        }
        tmp_args = [key];
        var fields = Object.keys(args);
        while (field = fields.shift()) {
            tmp_args.push(field, args[field]);
        }
        return this.send_command("hmset", tmp_args, callback);
    }
    return this.send_command("hmset", utils.to_array(arguments));
};

Multi.prototype.hmset = Multi.prototype.HMSET = function (key, args, callback) {
    var tmp_args, field;
    if (Array.isArray(key)) {
        if (args) {
            key = key.concat([args]);
        }
        tmp_args = ['hmset'].concat(key);
    } else if (Array.isArray(args)) {
        if (callback) {
            args = args.concat([callback]);
        }
        tmp_args = ['hmset', key].concat(args);
    } else if (typeof args === "object") {
        if (typeof key !== "string") {
            key = key.toString();
        }
        tmp_args = ["hmset", key];
        var fields = Object.keys(args);
        while (field = fields.shift()) {
            tmp_args.push(field);
            tmp_args.push(args[field]);
        }
        if (callback) {
            tmp_args.push(callback);
        }
    } else {
        tmp_args = utils.to_array(arguments);
        tmp_args.unshift("hmset");
    }
    this.queue.push(tmp_args);
    return this;
};

RedisClient.prototype.multi = RedisClient.prototype.MULTI = function (args) {
    return new Multi(this, args);
};